package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"time"
	"todo-service/internal/domain/entity"
	"todo-service/internal/infrastructure/gqlgen/graph/model"
	"todo-service/internal/service"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.CreateTodoInput) (*model.CreateTodoPayload, error) {
	// Parse DueDate from ISO 8601 string to time.Time
	var dueDate time.Time
	if input.DueDate != "" {
		var err error
		dueDate, err = time.Parse(time.RFC3339, input.DueDate)
		if err != nil {
			return nil, fmt.Errorf("invalid DueDate format: %w", err)
		}
	}

	todoItem := &entity.TodoItemEntity{
		Description: input.Description,
		DueDate:     dueDate.UTC(),
		FileID:      input.FileID,
		CreatedAt:   time.Now().UTC(),
	}

	if _, err := r.TodoUseCase.CreateTodo(ctx, todoItem); err != nil {
		return nil, err
	}

	return &model.CreateTodoPayload{
		Todo: &model.Todo{
			ID:          int32(todoItem.ID),
			Description: todoItem.Description,
			DueDate:     todoItem.DueDate.Format(time.RFC3339),
			FileID:      todoItem.FileID,
			CreatedAt:   todoItem.CreatedAt.Format(time.RFC3339),
		},
		Error: &model.FieldError{},
	}, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string) (*model.Todo, error) {
	iD, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}

	entity, err := r.TodoUseCase.GetTodoByID(ctx, iD)
	if err != nil {
		return nil, err
	}

	s := &model.Todo{
		ID:          int32(entity.ID),
		Description: entity.Description,
		DueDate:     entity.DueDate.Format(time.RFC3339),
		FileID:      id,
		CreatedAt:   entity.DueDate.Format(time.RFC3339),
	}

	return s, nil
}

// SearchTodos is the resolver for the searchTodos field.
func (r *queryResolver) SearchTodos(ctx context.Context, query string, offset int32, limit int32) (*model.SearchResult, error) {
	log.Printf("SearchTodos called - query: %s, limit: %+v, offset: %+v", query, limit, offset)

	off := 0
	lim := 10

	if offset != 0 {
		off = int(offset)
	}
	if limit != 0 {
		lim = int(limit)
	}

	redisSearch := service.DI().RedisSearch()

	results, total, err := redisSearch.SearchTodos(ctx, query, off, lim)
	if err != nil {
		fmt.Printf("error comes from %+v\n", err)
		return nil, err
	}

	todos := make([]*model.Todo, 0, len(results))
	for _, result := range results {

		id, err := strconv.Atoi(result["id"].(string))
		if err != nil {
			fmt.Printf("err %+v\n", err)
			continue
		}

		todo := &model.Todo{
			ID:          int32(id),
			Description: result["description"].(string),
			DueDate:     result["dueDate"].(string),
			CreatedAt:   result["createdAt"].(string),
			FileID:      result["fileid"].(string),
		}

		todos = append(todos, todo)
	}

	return &model.SearchResult{
		Results: todos,
		Total:   int32(total),
		Offset:  int32(off),
		Limit:   int32(lim),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
